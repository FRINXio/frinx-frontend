### This file was generated by Nexus Schema
### Do not make changes to this file directly

input AddBlueprintInput {
  name: String!
  template: String!
}

type AddBlueprintPayload {
  blueprint: Blueprint!
}

input AddDeviceInput {
  address: String
  blueprintId: String
  deviceSize: DeviceSize
  deviceType: String
  labelIds: [String!]
  model: String
  mountParameters: String
  name: String!
  password: String
  port: Int
  serviceState: DeviceServiceState
  username: String
  vendor: String
  version: String
  zoneId: String!
}

type AddDevicePayload {
  device: Device!
}

input AddLocationInput {
  countryId: String!
  name: String!
}

type AddLocationPayload {
  location: Location!
}

input AddSnapshotInput {
  deviceId: String!
  name: String!
}

type AddSnapshotPayload {
  snapshot: Snapshot
}

input AddZoneInput {
  name: String!
}

type AddZonePayload {
  zone: Zone!
}

input ApplySnapshotInput {
  deviceId: String!
  name: String!
}

type ApplySnapshotPayload {
  isOk: Boolean!
  output: String!
}

interface BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  softwareVersion: String
}

type Blueprint implements Node {
  createdAt: String!
  id: ID!
  name: String!
  template: String!
  updatedAt: String!
  version: Int
}

type BlueprintConnection {
  edges: [BlueprintEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BlueprintEdge {
  cursor: String!
  node: Blueprint!
}

input BulkOperationInput {
  executedWorkflowIds: [String!]!
}

type BulkOperationResponse {
  bulkErrorResults: String
  bulkSuccessfulResults: [String!]
}

type CSVImport {
  isOk: Boolean
}

input CSVImportInput {
  file: Upload!
  zoneId: String!
}

type CalculatedDiffPayload {
  result: CalculatedDiffResult!
}

type CalculatedDiffResult {
  createdData: [DiffData!]!
  deletedData: [DiffData!]!
  updatedData: [CalculatedUpdateDiffData!]!
}

type CalculatedUpdateDiffData {
  actualData: String!
  intendedData: String!
  path: String!
}

type CloseTransactionPayload {
  isOk: Boolean!
}

input CommitConfigInput {
  deviceId: String!
  shouldDryRun: Boolean
}

type CommitConfigOutput {
  configuration: String
  deviceId: String!
  message: String
}

type CommitConfigPayload {
  output: CommitConfigOutput!
}

type Country implements Node {
  code: String!
  id: ID!
  name: String!
  version: Int
}

type CountryConnection {
  edges: [CountryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CountryEdge {
  cursor: String!
  node: Country!
}

input CreateLabelInput {
  name: String!
}

type CreateLabelPayload {
  label: Label
}

input CreateScheduleInput {
  cronString: String!
  isEnabled: Boolean
  name: String!
  parallelRuns: Boolean
  performFromDate: String
  performTillDate: String
  workflowContext: String
  workflowName: String!
  workflowVersion: String!
}

type CreateTransactionPayload {
  transactionId: String
}

input CreateWorkflowInput {
  workflow: WorkflowInput!
}

type CreateWorkflowPayload {
  workflow: Workflow!
}

type DataStore {
  config: String!
  operational: String!
  snapshots: [Snapshot!]!
}

type DeleteBlueprintPayload {
  blueprint: Blueprint
}

type DeleteDevicePayload {
  device: Device
}

type DeleteLabelPayload {
  label: Label
}

input DeleteSnapshotInput {
  deviceId: String!
  name: String!
  transactionId: String!
}

type DeleteSnapshotPayload {
  snapshot: Snapshot
}

input DeleteWorkflowInput {
  name: String!
  version: Int!
}

type DeleteWorkflowPayload {
  workflow: Workflow!
}

type Device implements Node {
  address: String
  blueprint: Blueprint
  createdAt: String!
  deviceSize: DeviceSize!
  id: ID!
  isInstalled: Boolean!
  labels(after: String, before: String, first: Int, last: Int): LabelConnection!
  location: Location
  model: String
  mountParameters: String
  name: String!
  port: Int
  serviceState: DeviceServiceState!
  source: DeviceSource!
  updatedAt: String!
  vendor: String
  version: Int
  zone: Zone!
}

type DeviceConnection {
  edges: [DeviceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeviceEdge {
  cursor: String!
  node: Device!
}

input DeviceOrderByInput {
  direction: SortDirection!
  sortKey: SortDeviceBy!
}

enum DeviceServiceState {
  IN_SERVICE
  OUT_OF_SERVICE
  PLANNING
}

enum DeviceSize {
  LARGE
  MEDIUM
  SMALL
}

enum DeviceSource {
  DISCOVERED
  IMPORTED
  MANUAL
}

type DiffData {
  data: String!
  path: String!
}

type EdgeSourceTarget {
  interface: String!
  nodeId: String!
}

input EditWorkflowScheduleInput {
  cronString: String
  isEnabled: Boolean
  parallelRuns: Boolean
  performFromDate: String
  performTillDate: String
  workflowContext: String
  workflowName: String
  workflowVersion: String
}

input ExecuteNewWorkflowInput {
  correlationId: String
  externalInputPayloadStoragePath: String
  input: String
  name: String!
  priority: Int
  taskToDomain: String
  version: Int
}

input ExecuteWorkflowByName {
  correlationId: String

  """
  JSON string of input parameters
  """
  inputParameters: String!
  priority: Int
  workflowName: String!
  workflowVersion: Int
}

type ExecutedWorkflow implements Node {
  correlationId: String
  createdAt: String
  createdBy: String
  endTime: String
  failedReferenceTaskNames: [String]
  id: ID!
  input: String
  lastRetriedTime: String
  output: String
  ownerApp: String
  parentWorkflowId: String
  reasonForIncompletion: String
  startTime: String
  status: ExecutedWorkflowStatus
  tasks: [ExecutedWorkflowTask!]
  updatedAt: String
  updatedBy: String
  variables: String
  version: Int
  workflowDefinition: Workflow
  workflowId: String!
  workflowName: String
  workflowVersion: Int
}

type ExecutedWorkflowConnection {
  edges: [ExecutedWorkflowEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ExecutedWorkflowEdge {
  cursor: String!
  node: ExecutedWorkflow!
}

input ExecutedWorkflowFilterInput {
  startTime: ExecutedWorkflowStartTimeRange
  status: [ExecutedWorkflowStatus!]
  workflowId: [String!]
  workflowType: [String!]
}

input ExecutedWorkflowSearchInput {
  isRootWorkflow: Boolean
  query: ExecutedWorkflowFilterInput
}

input ExecutedWorkflowStartTimeRange {
  from: String!
  to: String
}

enum ExecutedWorkflowStatus {
  COMPLETED
  FAILED
  PAUSED
  RUNNING
  TERMINATED
  TIMED_OUT
}

type ExecutedWorkflowTask implements Node {
  callbackAfterSeconds: Int
  endTime: String
  executed: Boolean
  externalInputPayloadStoragePath: String
  externalOutputPayloadStoragePath: String
  id: ID!
  inputData: String
  outputData: String
  pollCount: Int
  reasonForIncompletion: String
  referenceTaskName: String
  retried: Boolean
  retryCount: Int
  scheduledTime: String
  seq: Int
  startTime: String
  status: ExecutedWorkflowTaskStatus
  subWorkflowId: String
  taskDefName: String
  taskDefinition: String
  taskId: String
  taskType: String
  updateTime: String
  version: Int
  workflowType: String
}

enum ExecutedWorkflowTaskStatus {
  CANCELED
  COMPLETED
  COMPLETED_WITH_ERROR
  FAILED
  FAILED_WITH_TERMINAL_ERROR
  IN_PROGRESS
  SCHEDULED
  SKIPPED
  TIMED_OUT
}

input FilterDevicesInput {
  deviceName: String
  labels: [String!]
}

input FilterPoolsInput {
  poolName: String
}

input FilterTopologyInput {
  labels: [String!]
}

input FilterWorkflowsInput {
  keyword: String
  labels: [String!]
}

input FreeResourceInput {
  poolId: String!
  resource: Record!
}

type GraphEdge {
  id: ID!
  source: EdgeSourceTarget!
  target: EdgeSourceTarget!
}

enum GraphEdgeStatus {
  ok
  unknown
}

type GraphNode implements BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  device: Device!
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  softwareVersion: String
}

type GraphNodeCoordinates {
  x: Float!
  y: Float!
}

input GraphNodeCoordinatesInput {
  deviceName: String!
  x: Float!
  y: Float!
}

type GraphNodeInterface {
  id: String!
  name: String!
  status: GraphEdgeStatus!
}

type GraphVersionEdge {
  id: ID!
  source: EdgeSourceTarget!
  target: EdgeSourceTarget!
}

type GraphVersionNode implements BaseGraphNode {
  coordinates: GraphNodeCoordinates!
  deviceType: String
  id: ID!
  interfaces: [GraphNodeInterface!]!
  name: String!
  softwareVersion: String
}

type InstallDevicePayload {
  device: Device!
}

type IsOkResponse {
  isOk: Boolean!
}

type Label implements Node {
  createdAt: String!
  id: ID!
  name: String!
  updatedAt: String!
  version: Int
}

type LabelConnection {
  edges: [LabelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LabelEdge {
  cursor: String!
  node: Label!
}

type Location implements Node {
  country: String!
  createdAt: String!
  id: ID!
  name: String!
  updatedAt: String!
  version: Int
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

type Mutation {
  addBlueprint(input: AddBlueprintInput!): AddBlueprintPayload!
  addDevice(input: AddDeviceInput!): AddDevicePayload!
  addLocation(input: AddLocationInput!): AddLocationPayload!
  addSnapshot(input: AddSnapshotInput!, transactionId: String!): AddSnapshotPayload
  addZone(input: AddZoneInput!): AddZonePayload!
  applySnapshot(input: ApplySnapshotInput!, transactionId: String!): ApplySnapshotPayload!
  bulkPauseWorkflow(input: BulkOperationInput!): BulkOperationResponse
  bulkRestartWorkflow(input: BulkOperationInput!): BulkOperationResponse
  bulkResumeWorkflow(input: BulkOperationInput!): BulkOperationResponse
  bulkRetryWorkflow(input: BulkOperationInput!): BulkOperationResponse
  bulkTerminateWorkflow(input: BulkOperationInput!): BulkOperationResponse
  closeTransaction(deviceId: String!, transactionId: String!): CloseTransactionPayload!
  commitConfig(input: CommitConfigInput!, transactionId: String!): CommitConfigPayload!
  createLabel(input: CreateLabelInput!): CreateLabelPayload!
  createTransaction(deviceId: String!): CreateTransactionPayload!
  createWorkflow(input: CreateWorkflowInput!): CreateWorkflowPayload!
  deleteBlueprint(id: String!): DeleteBlueprintPayload!
  deleteDevice(id: String!): DeleteDevicePayload!
  deleteLabel(id: String!): DeleteLabelPayload!
  deleteSchedule(id: String!): IsOkResponse
  deleteSnapshot(input: DeleteSnapshotInput!): DeleteSnapshotPayload
  deleteWorkflow(input: DeleteWorkflowInput!): DeleteWorkflowPayload!
  editWorkflowSchedule(id: String!, input: EditWorkflowScheduleInput!): Schedule
  executeNewWorkflow(input: StartWorkflowRequestInput!): String
  executeWorkflowByName(input: ExecuteWorkflowByName!): String
  freeResource(input: FreeResourceInput!): String
  importCSV(input: CSVImportInput!): CSVImport
  installDevice(id: String!): InstallDevicePayload!
  pauseWorkflow(id: String!): IsOkResponse
  removeWorkflow(id: String!, input: RemoveWorkflowInput): IsOkResponse
  resetConfig(deviceId: String!, transactionId: String!): ResetConfigPayload!
  restartWorkflow(id: String!, input: RestartWorkflowInput): IsOkResponse
  resumeWorkflow(id: String!): IsOkResponse
  retryWorkflow(id: String!, input: RetryWorkflowInput): IsOkResponse
  revertChanges(transactionId: String!): RevertChangesPayload!
  scheduleWorkflow(input: CreateScheduleInput!): Schedule
  syncFromNetwork(deviceId: String!, transactionId: String!): SyncFromNetworkPayload!
  terminateWorkflow(id: String!, input: TerminateWorkflowInput): IsOkResponse
  uninstallDevice(id: String!): UninstallDevicePayload!
  updateBlueprint(id: String!, input: UpdateBlueprintInput!): UpdateBlueprintPayload!
  updateDataStore(deviceId: String!, input: UpdateDataStoreInput!, transactionId: String!): UpdateDataStorePayload!
  updateDevice(id: String!, input: UpdateDeviceInput!): UpdateDevicePayload!
  updateGraphNodeCoordinates(input: [GraphNodeCoordinatesInput!]!): UpdateGraphNodeCoordinatesPayload!
  updateWorkflow(id: String!, input: UpdateWorkflowInput!): UpdateWorkflowPayload!
}

type NetInterface {
  id: String!
  name: String!
}

type NetNetwork {
  coordinates: GraphNodeCoordinates!
  id: String!
  subnet: String!
}

type NetNode {
  coordinates: GraphNodeCoordinates!
  id: ID!
  interfaces: [NetInterface!]!
  name: String!
  networks: [NetNetwork!]!
}

type NetTopology {
  edges: [GraphEdge!]!
  nodes: [NetNode!]!
}

interface Node {
  id: ID!
  version: Int
}

type OutputParameter {
  key: String!
  value: String!
}

input OutputParameterInput {
  key: String!
  value: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PaginationArgs {
  size: Int!
  start: Int!
}

type Pool implements Node {
  id: ID!
  name: String!
  poolType: PoolType!
  resourceType: ResourceType!
  tags: [Tag!]!
  version: Int
}

type PoolConnection {
  edges: [PoolEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PoolEdge {
  cursor: String!
  node: Pool!
}

enum PoolType {
  allocating
  set
  singleton
}

type Query {
  blueprints(after: String, before: String, first: Int, last: Int): BlueprintConnection!
  calculatedDiff(deviceId: String!, transactionId: String!): CalculatedDiffPayload!
  countries(after: String, before: String, first: Int, last: Int): CountryConnection!
  dataStore(deviceId: String!, transactionId: String!): DataStore
  devices(
    after: String
    before: String
    filter: FilterDevicesInput
    first: Int
    last: Int
    orderBy: DeviceOrderByInput
  ): DeviceConnection!
  executedWorkflows(pagination: PaginationArgs, searchQuery: ExecutedWorkflowSearchInput): ExecutedWorkflowConnection
  labels(after: String, before: String, first: Int, last: Int): LabelConnection!
  locations(after: String, before: String, first: Int, last: Int): LocationConnection!
  netTopology: NetTopology
  node(id: ID!, version: Int): Node
  pools(
    after: String
    before: String
    filter: FilterPoolsInput
    first: Int
    last: Int
    resourceTypeId: String
  ): PoolConnection!
  schedules(after: String, before: String, filter: ScheduleFilterInput, first: Int, last: Int): ScheduleConnection!
  taskDefinitions: [TaskDefinition!]!
  topology(filter: FilterTopologyInput): Topology
  topologyCommonNodes(nodes: [String!]!): TopologyCommonNodes
  topologyVersionData(version: String!): TopologyVersionData!
  topologyVersions: [String!]
  transactions: [Transaction!]!
  uniconfigShellSession: String
  workflowInstanceDetail(shouldIncludeTasks: Boolean, workflowId: String!): WorkflowInstanceDetail
  workflowLabels: [String!]!
  workflows(after: String, before: String, filter: FilterWorkflowsInput, first: Int, last: Int): WorkflowConnection!
  zones(after: String, before: String, first: Int, last: Int): ZonesConnection!
}

"""
Graphql custom scalar record type
"""
scalar Record

input RemoveWorkflowInput {
  """
  Default value is true
  """
  shouldArchiveWorkflow: Boolean
}

type ResetConfigPayload {
  dataStore: DataStore!
}

type ResourceType {
  id: ID!
  name: String!
}

input ResourceTypeInput {
  resourceTypeId: String
}

input RestartWorkflowInput {
  """
  Default value is true
  """
  shouldUseLatestDefinitions: Boolean
}

enum RetryLogic {
  EXPONENTIAL_BACKOFF
  FIXED
  LINEAR_BACKOFF
}

input RetryWorkflowInput {
  """
  Default value is true
  """
  shouldResumeSubworkflowTasks: Boolean
}

type RevertChangesPayload {
  isOk: Boolean!
}

type Schedule implements Node {
  cronString: String!
  id: ID!
  isEnabled: Boolean!
  name: String!
  parallelRuns: Boolean!
  performFromDate: String!
  performTillDate: String!
  status: ScheduleStatus!
  version: Int
  workflowContext: String!
  workflowName: String!
  workflowVersion: String!
}

type ScheduleConnection {
  edges: [ScheduleEdge]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ScheduleEdge {
  cursor: String!
  node: Schedule!
}

input ScheduleFilterInput {
  workflowName: String!
  workflowVersion: String!
}

enum ScheduleStatus {
  COMPLETED
  FAILED
  PAUSED
  RUNNING
  TERMINATED
  TIMED_OUT
  UNKNOWN
}

type Snapshot {
  createdAt: String!
  name: String!
}

enum SortDeviceBy {
  CREATED_AT
  NAME
}

enum SortDirection {
  ASC
  DESC
}

input StartWorkflowRequestInput {
  workflow: ExecuteNewWorkflowInput!
  workflowDefinition: WorkflowDefinitionInput
}

type SubWorkflow {
  executedWorkflowDetail: ExecutedWorkflow!
  referenceTaskName: String!
  workflowDetail: Workflow!
}

type Subscription {
  controlExecutedWorkflow(id: String!): ExecutedWorkflow
  uniconfigShell(input: String, sessionId: String!, trigger: Int): String
}

type SyncFromNetworkPayload {
  dataStore: DataStore
}

type Tag {
  id: ID!
  tag: String!
}

type TaskDefinition {
  concurrentExecLimit: Int
  createdAt: String
  createdBy: String
  description: String
  inputKeys: [String!]
  inputTemplate: String
  name: String!
  outputKeys: [String!]
  ownerEmail: String
  pollTimeoutSeconds: Int
  rateLimitFrequencyInSeconds: Int
  rateLimitPerFrequency: Int
  responseTimeoutSeconds: Int
  retryCount: Int
  retryDelaySeconds: Int
  retryLogic: RetryLogic
  timeoutPolicy: TaskTimeoutPolicy
  timeoutSeconds: Int!
  updatedAt: String
  updatedBy: String
}

input TaskInput {
  asyncComplete: Boolean
  decisionCases: String
  defaultCase: String
  description: String
  inputParameters: String
  joinOn: [String]
  loopCondition: String
  name: String!
  optional: Boolean
  retryCount: Int
  startDelay: Int
  taskReferenceName: String!
  type: String
  workflowTaskType: [WorkflowTaskType]
}

enum TaskTimeoutPolicy {
  ALERT_ONLY
  RETRY
  TIME_OUT_WF
}

input TerminateWorkflowInput {
  reason: String
}

enum TimeoutPolicy {
  ALERT_ONLY
  TIME_OUT_WF
}

type Topology {
  edges: [GraphEdge!]!
  nodes: [GraphNode!]!
}

type TopologyCommonNodes {
  commonNodes: [String!]!
}

type TopologyVersionData {
  edges: [GraphVersionEdge!]!
  nodes: [GraphVersionNode!]!
}

type Transaction {
  changes: [TransactionChange!]!
  lastCommitTime: String!
  transactionId: String!
}

type TransactionChange {
  device: Device!
  diff: [TransactionDiff!]!
}

type TransactionDiff {
  dataAfter: String
  dataBefore: String
  path: String!
}

type UninstallDevicePayload {
  device: Device!
}

input UpdateBlueprintInput {
  name: String
  template: String
}

type UpdateBlueprintPayload {
  blueprint: Blueprint!
}

input UpdateDataStoreInput {
  config: String!
}

type UpdateDataStorePayload {
  dataStore: DataStore!
}

input UpdateDeviceInput {
  address: String
  blueprintId: String
  deviceSize: DeviceSize
  deviceType: String
  labelIds: [String!]
  locationId: String
  model: String
  mountParameters: String
  password: String
  port: Int
  serviceState: DeviceServiceState
  username: String
  vendor: String
  version: String
}

type UpdateDeviceMetadataPayload {
  devices: [Device]
}

type UpdateDevicePayload {
  device: Device
}

type UpdateGraphNodeCoordinatesPayload {
  deviceNames: [String!]!
}

input UpdateWorkflowInput {
  workflow: WorkflowInput!
}

type UpdateWorkflowPayload {
  workflow: Workflow!
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

type Workflow implements Node {
  createdAt: String
  createdBy: String
  description: String
  hasSchedule: Boolean
  id: ID!
  inputParameters: [String!]
  name: String!
  outputParameters: [OutputParameter!]
  restartable: Boolean
  tasks: String
  timeoutPolicy: TimeoutPolicy
  timeoutSeconds: Int!
  updatedAt: String
  updatedBy: String
  version: Int
}

type WorkflowConnection {
  edges: [WorkflowEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input WorkflowDefinitionInput {
  createTime: Int
  createdAt: Int
  createdBy: String
  description: String
  inputParameters: [String]
  inputTemplate: String
  name: String!
  outputParameters: String
  ownerApp: String
  ownerEmail: String
  restartable: Boolean
  schemaVersion: Int
  tasks: [TaskInput!]!
  timeoutPolicy: TimeoutPolicy
  timeoutSeconds: Int!
  updateTime: Int
  updatedAt: Int
  updatedBy: String
  variables: String
  version: Int
}

type WorkflowEdge {
  cursor: String!
  node: Workflow!
}

input WorkflowInput {
  createdAt: String
  description: String
  name: String!
  outputParameters: [OutputParameterInput!]
  restartable: Boolean
  tasks: String!
  timeoutSeconds: Int!
  updatedAt: String
  version: Int
}

type WorkflowInstanceDetail {
  meta: Workflow
  result: ExecutedWorkflow!
  subworkflows: [SubWorkflow!]
}

enum WorkflowTaskType {
  DECISION
  DO_WHILE
  DYNAMIC
  EVENT
  EXCLUSIVE_JOIN
  FORK_JOIN
  FORK_JOIN_DYNAMIC
  HTTP
  HUMAN
  INLINE
  JOIN
  JSON_JQ_TRANSFORM
  KAFKA_PUBLISH
  LAMBDA
  SET_VARIABLE
  SIMPLE
  START_WORKFLOW
  SUB_WORKFLOW
  SWITCH
  TERMINATE
  USER_DEFINED
  WAIT
}

type Zone implements Node {
  createdAt: String!
  id: ID!
  name: String!
  updatedAt: String!
  version: Int
}

type ZoneEdge {
  cursor: String!
  node: Zone!
}

type ZonesConnection {
  edges: [ZoneEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
